# Day 1 — 사전 지식 정리

## [컴퓨터 공학 지식 정리]
- **스택 vs 힙 vs 저장소**: 일반 애플리케이션 언어와 달리 Solidity는 EVM 가상머신 위에서 실행된다. 함수 안의 지역 변수는 스택에, 구조체/배열 등 동적 데이터는 메모리(힙과 비슷한 개념)에, 그리고 블록체인에 영구 저장되는 상태 변수는 스토리지에 놓인다. 스토리지는 읽기·쓰기 비용이 매우 비싸므로 상태를 설계할 때 최소화해야 한다.
- **ABI (Application Binary Interface)**: Solidity 컨트랙트와 외부 세계(다른 컨트랙트, 프론트엔드)가 통신할 때 사용하는 표준 규격이다. 함수 시그니처를 4바이트 셀렉터로 해시하고, 인자들을 32바이트 슬롯으로 패딩해 전송한다. Foundry의 `forge build`는 ABI JSON을 생성하므로, 이를 확인하면 함수의 인코딩 방식을 이해하는 데 도움이 된다.
- **테스트 더블과 시뮬레이션**: Foundry의 `vm` 체인은 특정 시점의 체인 상태를 흉내 내는 실행 환경(cheatcode)을 제공한다. 이는 소프트웨어 테스트에서의 목(mock)/스텁과 유사한 개념으로, 계정 주소·잔액·블록 정보를 마음대로 세팅해 다양한 시나리오를 검증할 수 있게 해 준다.

## [금융 공학 지식]
- **가치 보존과 회계적 사고**: 스마트 컨트랙트가 다루는 ETH나 토큰은 실질적인 경제적 가치를 가진다. 입금(Deposit) 기능을 설계할 때는 "자산이 어디에서 와서 어디로 이동했는가?"를 항상 추적해야 한다. 전통 회계에서 차변/대변을 맞추듯이, 컨트랙트에서도 `msg.value`가 상태 변수에 제대로 기록되고, 이벤트로 외부 감사가 가능한 로그를 남겼는지 확인해야 한다.
- **유동성(Liquidity)의 첫걸음**: 오늘 과제의 `DayOneVault`는 단순한 금고이지만, 추후 DEX나 DeFi 프로토콜에서도 핵심은 "누가 얼마나 자산을 넣었고, 어떤 조건으로 인출할 수 있는가"이다. 주소별 누적 입금액을 추적하는 지금의 패턴이 이후 유동성 풀, 예치금(Accounting) 설계의 기본이 된다.
