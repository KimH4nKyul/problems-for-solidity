# Day 4 YOU_MUST_KNOW

## 컴퓨터 공학 지식 정리
1. **Merkle Tree**: 해시 트리를 이용해 많은 데이터 조각을 하나의 `root`로 요약합니다. 각 leaf는 해시로 표현되고, 부모 노드는 자식 해시를 연결한 값을 다시 해시합니다. 검증자는 leaf와 root, 그리고 형제 노드들의 해시(merkle proof)를 사용해 O(log n) 시간에 진위를 확인할 수 있습니다.
2. **비트맵(bitmap)**: bool 배열을 256bit 정수 하나로 압축하는 구조입니다. `wordIndex = index / 256`, `bitIndex = index % 256`으로 자리를 구하고 `mask = 1 << bitIndex`를 이용해 체크/셋을 수행합니다. 비트 연산은 매우 저렴하여 대규모 청구 상태 관리에 쓰입니다.
3. **재진입 안전성**: 외부 호출(`token.transfer`) 전에 내부 상태(잔액, 비트맵)를 먼저 업데이트하고, 실패 시 전체 트랜잭션을 되돌릴 수 있도록 boolean 리턴을 확인해야 합니다.
4. **솔리디티 메모리 vs 스토리지**: 머클 proof 배열은 calldata에 있으므로 읽기 전용입니다. 비트맵은 `mapping(uint256 => uint256)` 형태의 storage에 두고 `_setClaimed` 같은 내부 함수에서 직접 수정합니다.

## 금융 공학 지식
1. **에어드롭(Airdrop)**: 특정 스냅샷 시점의 사용자에게 토큰을 배포하는 이벤트입니다. 신뢰 없이 대량 배포하려면 오프체인에서 자격을 계산하고 온체인에서 머클 proof로 검증합니다.
2. **에스크로(Escrow)**: 제3자가 자금을 보관했다가 조건이 충족되면 지급하는 구조입니다. Epoch별로 예치 잔액을 분리하면 특정 배치가 초과 청구되지 않도록 관리할 수 있습니다.
3. **보상 소진 추적**: 토큰 공급이 제한된 상황에서 같은 인덱스가 두 번 청구되는 것을 막지 못하면 전체 분배 계획이 깨집니다. 비트맵은 금융 데이터의 “소진 상태”를 저렴하게 추적하는 대표 기법입니다.
